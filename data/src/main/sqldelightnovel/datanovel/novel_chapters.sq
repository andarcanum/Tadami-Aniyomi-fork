import kotlin.Boolean;

CREATE TABLE novel_chapters(
    _id INTEGER NOT NULL PRIMARY KEY,
    novel_id INTEGER NOT NULL,
    url TEXT NOT NULL,
    name TEXT NOT NULL,
    scanlator TEXT,
    read INTEGER AS Boolean NOT NULL,
    bookmark INTEGER AS Boolean NOT NULL,
    last_page_read INTEGER NOT NULL,
    chapter_number REAL NOT NULL,
    source_order INTEGER NOT NULL,
    date_fetch INTEGER NOT NULL,
    date_upload INTEGER NOT NULL,
    last_modified_at INTEGER NOT NULL DEFAULT 0,
    version INTEGER NOT NULL DEFAULT 0,
    is_syncing INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY(novel_id) REFERENCES novels (_id)
    ON DELETE CASCADE
);

CREATE INDEX novel_chapters_novel_id_index ON novel_chapters(novel_id);
CREATE INDEX novel_chapters_unread_by_novel_index ON novel_chapters(novel_id, read) WHERE read = 0;

CREATE TRIGGER update_last_modified_at_novel_chapters
AFTER UPDATE ON novel_chapters
FOR EACH ROW
BEGIN
  UPDATE novel_chapters
  SET last_modified_at = strftime('%s', 'now')
  WHERE _id = new._id;
END;

CREATE TRIGGER update_chapter_and_novel_version AFTER UPDATE ON novel_chapters
WHEN new.is_syncing = 0 AND (
    new.read != old.read OR
    new.bookmark != old.bookmark OR
    new.last_page_read != old.last_page_read
)
BEGIN
    -- Update the chapter version
    UPDATE novel_chapters SET version = version + 1
    WHERE _id = new._id;

    -- Update the novel version
    UPDATE novels SET version = version + 1
    WHERE _id = new.novel_id AND (SELECT is_syncing FROM novels WHERE _id = new.novel_id) = 0;
END;

getChapterById:
SELECT *
FROM novel_chapters
WHERE _id = :id;

getChaptersByNovelId:
SELECT C.*
FROM novel_chapters C
LEFT JOIN novel_excluded_scanlators ES
ON C.novel_id = ES.novel_id
AND C.scanlator = ES.scanlator
WHERE C.novel_id = :novelId
AND (
    :applyScanlatorFilter = 0
    OR ES.scanlator IS NULL
);

getScanlatorsByNovelId:
SELECT scanlator
FROM novel_chapters
WHERE novel_id = :novelId;

getBookmarkedChaptersByNovelId:
SELECT *
FROM novel_chapters
WHERE bookmark
AND novel_id = :novelId;

getChapterByUrl:
SELECT *
FROM novel_chapters
WHERE url = :chapterUrl;

getChapterByUrlAndNovelId:
SELECT *
FROM novel_chapters
WHERE url = :chapterUrl
AND novel_id = :novelId;

removeChaptersWithIds:
DELETE FROM novel_chapters
WHERE _id IN :chapterIds;

resetIsSyncing:
UPDATE novel_chapters
SET is_syncing = 0
WHERE is_syncing = 1;

insert:
INSERT INTO novel_chapters(novel_id, url, name, scanlator, read, bookmark, last_page_read, chapter_number, source_order, date_fetch, date_upload, last_modified_at, version, is_syncing)
VALUES (:novelId, :url, :name, :scanlator, :read, :bookmark, :lastPageRead, :chapterNumber, :sourceOrder, :dateFetch, :dateUpload, 0, :version, 0);

update:
UPDATE novel_chapters
SET novel_id = coalesce(:novelId, novel_id),
    url = coalesce(:url, url),
    name = coalesce(:name, name),
    scanlator = coalesce(:scanlator, scanlator),
    read = coalesce(:read, read),
    bookmark = coalesce(:bookmark, bookmark),
    last_page_read = coalesce(:lastPageRead, last_page_read),
    chapter_number = coalesce(:chapterNumber, chapter_number),
    source_order = coalesce(:sourceOrder, source_order),
    date_fetch = coalesce(:dateFetch, date_fetch),
    date_upload = coalesce(:dateUpload, date_upload),
    version = coalesce(:version, version),
    is_syncing = coalesce(:isSyncing, is_syncing)
WHERE _id = :chapterId;

selectLastInsertedRowId:
SELECT last_insert_rowid();

getChapterCountByNovelId:
SELECT COUNT(*) FROM novel_chapters
WHERE novel_id = :novelId;
